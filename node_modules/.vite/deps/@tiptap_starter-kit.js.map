{
  "version": 3,
  "sources": ["../../@tiptap/core/src/jsx-runtime.ts", "../../@tiptap/extension-blockquote/src/blockquote.tsx", "../../@tiptap/extension-blockquote/src/index.ts", "../../@tiptap/extension-bold/src/bold.tsx", "../../@tiptap/extension-bold/src/index.ts", "../../@tiptap/extension-code/src/code.ts", "../../@tiptap/extension-code/src/index.ts", "../../@tiptap/extension-code-block/src/code-block.ts", "../../@tiptap/extension-code-block/src/index.ts", "../../@tiptap/extension-document/src/document.ts", "../../@tiptap/extension-document/src/index.ts", "../../@tiptap/extension-hard-break/src/hard-break.ts", "../../@tiptap/extension-hard-break/src/index.ts", "../../@tiptap/extension-heading/src/heading.ts", "../../@tiptap/extension-heading/src/index.ts", "../../@tiptap/extension-horizontal-rule/src/horizontal-rule.ts", "../../@tiptap/extension-horizontal-rule/src/index.ts", "../../@tiptap/extension-italic/src/italic.ts", "../../@tiptap/extension-italic/src/index.ts", "../../@tiptap/extension-list/src/bullet-list/bullet-list.ts", "../../@tiptap/extension-list/src/item/list-item.ts", "../../@tiptap/extension-list/src/keymap/list-keymap.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/index.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/findListItemPos.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/getNextListDepth.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/handleBackspace.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListBefore.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListItemBefore.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/listItemHasSubList.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/handleDelete.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/nextListIsDeeper.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/nextListIsHigher.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListItemAfter.ts", "../../@tiptap/extension-list/src/kit/index.ts", "../../@tiptap/extension-list/src/ordered-list/ordered-list.ts", "../../@tiptap/extension-list/src/ordered-list/utils.ts", "../../@tiptap/extension-list/src/task-item/task-item.ts", "../../@tiptap/extension-list/src/task-list/task-list.ts", "../../@tiptap/extension-paragraph/src/paragraph.ts", "../../@tiptap/extension-paragraph/src/index.ts", "../../@tiptap/extension-strike/src/strike.ts", "../../@tiptap/extension-strike/src/index.ts", "../../@tiptap/extension-text/src/text.ts", "../../@tiptap/extension-text/src/index.ts", "../../prosemirror-dropcursor/dist/index.js", "../../prosemirror-gapcursor/dist/index.js", "../../rope-sequence/dist/index.js", "../../prosemirror-history/dist/index.js", "../../@tiptap/extensions/src/character-count/character-count.ts", "../../@tiptap/extensions/src/drop-cursor/drop-cursor.ts", "../../@tiptap/extensions/src/focus/focus.ts", "../../@tiptap/extensions/src/gap-cursor/gap-cursor.ts", "../../@tiptap/extensions/src/placeholder/placeholder.ts", "../../@tiptap/extensions/src/selection/selection.ts", "../../@tiptap/extensions/src/trailing-node/trailing-node.ts", "../../@tiptap/extensions/src/undo-redo/undo-redo.ts", "../../@tiptap/starter-kit/src/starter-kit.ts", "../../@tiptap/starter-kit/src/index.ts"],
  "sourcesContent": ["export type Attributes = Record<string, any>\n\nexport type DOMOutputSpecElement = 0 | Attributes | DOMOutputSpecArray\n/**\n * Better describes the output of a `renderHTML` function in prosemirror\n * @see https://prosemirror.net/docs/ref/#model.DOMOutputSpec\n */\nexport type DOMOutputSpecArray =\n  | [string]\n  | [string, Attributes]\n  | [string, 0]\n  | [string, Attributes, 0]\n  | [string, Attributes, DOMOutputSpecArray | 0]\n  | [string, DOMOutputSpecArray]\n\n// JSX types for Tiptap's JSX runtime\n// These types only apply when using @jsxImportSource @tiptap/core\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace JSX {\n  export type Element = DOMOutputSpecArray\n  export interface IntrinsicElements {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n  export interface ElementChildrenAttribute {\n    children: unknown\n  }\n}\n\nexport type JSXRenderer = (\n  tag: 'slot' | string | ((props?: Attributes) => DOMOutputSpecArray | DOMOutputSpecElement),\n  props?: Attributes,\n  ...children: JSXRenderer[]\n) => DOMOutputSpecArray | DOMOutputSpecElement\n\nexport function Fragment(props: { children: JSXRenderer[] }) {\n  return props.children\n}\n\nexport const h: JSXRenderer = (tag, attributes) => {\n  // Treat the slot tag as the Prosemirror hole to render content into\n  if (tag === 'slot') {\n    return 0\n  }\n\n  // If the tag is a function, call it with the props\n  if (tag instanceof Function) {\n    return tag(attributes)\n  }\n\n  const { children, ...rest } = attributes ?? {}\n\n  if (tag === 'svg') {\n    throw new Error('SVG elements are not supported in the JSX syntax, use the array syntax instead')\n  }\n\n  // Otherwise, return the tag, attributes, and children\n  return [tag, rest, children]\n}\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport { h as createElement, h as jsx, h as jsxDEV, h as jsxs }\n", "/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Blockquote } from './blockquote.jsx'\n\nexport * from './blockquote.jsx'\n\nexport default Blockquote\n", "/** @jsxImportSource @tiptap/core */\nimport { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface BoldOptions {\n  /**\n   * HTML attributes to add to the bold element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches bold text via `**` as input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/\n\n/**\n * Matches bold text via `**` while pasting.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g\n\n/**\n * Matches bold text via `__` as input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/\n\n/**\n * Matches bold text via `__` while pasting.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g\n\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight=400',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <strong {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </strong>\n    )\n  },\n\n  markdownTokenName: 'strong',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'strong' token to bold mark\n    return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`\n  },\n\n  addCommands() {\n    return {\n      setBold:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleBold:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetBold:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Bold } from './bold.jsx'\n\nexport * from './bold.jsx'\n\nexport default Bold\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface CodeOptions {\n  /**\n   * The HTML attributes applied to the code element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType\n    }\n  }\n}\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick as the final character.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nexport const inputRegex = /(^|[^`])`([^`]+)`(?!`)$/\n\n/**\n * Matches inline code while pasting.\n */\nexport const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g\n\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  exitable: true,\n\n  parseHTML() {\n    return [{ tag: 'code' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'codespan',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'codespan' token to code mark\n    // For codespan tokens, we use the raw text content, not tokens\n    return helpers.applyMark('code', [{ type: 'text', text: token.text || '' }])\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return `\\`${h.renderChildren(node.content)}\\``\n  },\n\n  addCommands() {\n    return {\n      setCode:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleCode:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetCode:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Code } from './code.js'\n\nexport * from './code.js'\n\nexport default Code\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // don’t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { CodeBlock } from './code-block.js'\n\nexport * from './code-block.js'\n\nexport default CodeBlock\n", "import { Node } from '@tiptap/core'\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n\\n')\n  },\n})\n", "import { Document } from './document.js'\n\nexport * from './document.js'\n\nexport default Document\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  /**\n   * Controls if marks should be kept after being split by a hard break.\n   * @default true\n   * @example false\n   */\n  keepMarks: boolean\n\n  /**\n   * HTML attributes to add to the hard break element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       * @example editor.commands.setHardBreak()\n       */\n      setHardBreak: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  markdownTokenName: 'br',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  parseHTML() {\n    return [{ tag: 'br' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  renderMarkdown: () => `  \\n`,\n\n  parseMarkdown: () => {\n    return {\n      type: 'hardBreak',\n    }\n  },\n\n  addCommands() {\n    return {\n      setHardBreak:\n        () =>\n        ({ commands, chain, state, editor }) => {\n          return commands.first([\n            () => commands.exitCode(),\n            () =>\n              commands.command(() => {\n                const { selection, storedMarks } = state\n\n                if (selection.$from.parent.type.spec.isolating) {\n                  return false\n                }\n\n                const { keepMarks } = this.options\n                const { splittableMarks } = editor.extensionManager\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n                return chain()\n                  .insertContent({ type: this.name })\n                  .command(({ tr, dispatch }) => {\n                    if (dispatch && marks && keepMarks) {\n                      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n                      tr.ensureMarks(filteredMarks)\n                    }\n\n                    return true\n                  })\n                  .run()\n              }),\n          ])\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n", "import { HardBreak } from './hard-break.js'\n\nexport * from './hard-break.js'\n\nexport default HardBreak\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\n\n/**\n * The heading level options.\n */\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  /**\n   * The available heading levels.\n   * @default [1, 2, 3, 4, 5, 6]\n   * @example [1, 2, 3]\n   */\n  levels: Level[]\n\n  /**\n   * The HTML attributes for a heading node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.setHeading({ level: 1 })\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType\n      /**\n       * Toggle a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.toggleHeading({ level: 1 })\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels.map((level: Level) => ({\n      tag: `h${level}`,\n      attrs: { level },\n    }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel ? node.attrs.level : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'heading' token to heading node\n    // marked provides 'depth' property (1-6) for heading level\n    return helpers.createNode('heading', { level: token.depth || 1 }, helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    const level = node.attrs?.level ? parseInt(node.attrs.level as string, 10) : 1\n    const headingChars = '#'.repeat(level)\n\n    if (!node.content) {\n      return ''\n    }\n\n    // Use current context for proper joining/spacing\n    return `${headingChars} ${h.renderChildren(node.content)}`\n  },\n\n  addCommands() {\n    return {\n      setHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.setNode(this.name, attributes)\n        },\n      toggleHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n        },\n      }),\n      {},\n    )\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n", "import { Heading } from './heading.js'\n\nexport * from './heading.js'\n\nexport default Heading\n", "import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface ItalicOptions {\n  /**\n   * HTML attributes to add to the italic element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       * @example editor.commands.setItalic()\n       */\n      setItalic: () => ReturnType\n      /**\n       * Toggle an italic mark\n       * @example editor.commands.toggleItalic()\n       */\n      toggleItalic: () => ReturnType\n      /**\n       * Unset an italic mark\n       * @example editor.commands.unsetItalic()\n       */\n      unsetItalic: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an italic to a *italic* on input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/\n\n/**\n * Matches an italic to a *italic* on paste.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g\n\n/**\n * Matches an italic to a _italic_ on input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/\n\n/**\n * Matches an italic to a _italic_ on paste.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g\n\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=normal',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleItalic:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetItalic:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  markdownTokenName: 'em',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'em' token to italic mark\n    return helpers.applyMark('italic', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Italic } from './italic.js'\n\nexport * from './italic.js'\n\nexport default Italic\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          return `${context.index + 1}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n", "import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n", "export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n", "import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n", "import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * It’s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n", "import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { mergeAttributes, Node, renderNestedMarkdownContent, wrappingInputRule } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isn’t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n", "import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  /**\n   * The HTML attributes for a paragraph node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       * @example editor.commands.toggleParagraph()\n       */\n      setParagraph: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [{ tag: 'p' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || []\n\n    // Special case: if paragraph contains only a single image token,\n    // unwrap it to avoid nesting block elements incorrectly\n    if (tokens.length === 1 && tokens[0].type === 'image') {\n      // Parse the image token directly as a block element\n      return helpers.parseChildren([tokens[0]])\n    }\n\n    // Convert 'paragraph' token to paragraph node\n    return helpers.createNode(\n      'paragraph',\n      undefined, // no attributes for paragraph\n      helpers.parseInline(tokens),\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node || !Array.isArray(node.content)) {\n      return ''\n    }\n\n    return h.renderChildren(node.content)\n  },\n\n  addCommands() {\n    return {\n      setParagraph:\n        () =>\n        ({ commands }) => {\n          return commands.setNode(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n", "import { Paragraph } from './paragraph.js'\n\nexport * from './paragraph.js'\n\nexport default Paragraph\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface StrikeOptions {\n  /**\n   * HTML attributes to add to the strike element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       * @example editor.commands.setStrike()\n       */\n      setStrike: () => ReturnType\n      /**\n       * Toggle a strike mark\n       * @example editor.commands.toggleStrike()\n       */\n      toggleStrike: () => ReturnType\n      /**\n       * Unset a strike mark\n       * @example editor.commands.unsetStrike()\n       */\n      unsetStrike: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nexport const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/\n\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g\n\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'del',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'del' token to strike mark\n    return helpers.applyMark('strike', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`\n  },\n\n  addCommands() {\n    return {\n      setStrike:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleStrike:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetStrike:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Strike } from './strike.js'\n\nexport * from './strike.js'\n\nexport default Strike\n", "import { Node } from '@tiptap/core'\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n\n  parseMarkdown: token => {\n    // Convert 'text' token to text node - text nodes are special as they store text directly\n    return {\n      type: 'text',\n      text: token.text || '',\n    }\n  },\n\n  renderMarkdown: node => node.text || '',\n})\n", "import { Text } from './text.js'\n\nexport * from './text.js'\n\nexport default Text\n", "import { Plugin } from 'prosemirror-state';\nimport { dropPoint } from 'prosemirror-transform';\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();\n        let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    let halfWidth = (this.width / 2) * scaleY;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            let halfWidth = (this.width / 2) * scaleX;\n            rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            let parentScaleX = rect.width / parent.offsetWidth, parentScaleY = rect.height / parent.offsetHeight;\n            parentLeft = rect.left - parent.scrollLeft * parentScaleX;\n            parentTop = rect.top - parent.scrollTop * parentScaleY;\n        }\n        this.element.style.left = (rect.left - parentLeft) / scaleX + \"px\";\n        this.element.style.top = (rect.top - parentTop) / scaleY + \"px\";\n        this.element.style.width = (rect.right - rect.left) / scaleX + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) / scaleY + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\"\n            ? disableDropCursor(this.editorView, pos, event)\n            : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (!this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\nexport { dropCursor };\n", "import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction needsGap(type) {\n    return type.isAtom || type.spec.isolating || type.spec.createGapCursor;\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || needsGap(before.type))\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || needsGap(after.type))\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n", "var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n", "import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n", "import { Extension } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface CharacterCountOptions {\n  /**\n   * The maximum number of characters that should be allowed. Defaults to `0`.\n   * @default null\n   * @example 180\n   */\n  limit: number | null | undefined\n  /**\n   * The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   * If set to `nodeSize`, the nodeSize of the document is used.\n   * @default 'textSize'\n   * @example 'textSize'\n   */\n  mode: 'textSize' | 'nodeSize'\n  /**\n   * The text counter function to use. Defaults to a simple character count.\n   * @default (text) => text.length\n   * @example (text) => [...new Intl.Segmenter().segment(text)].length\n   */\n  textCounter: (text: string) => number\n  /**\n   * The word counter function to use. Defaults to a simple word count.\n   * @default (text) => text.split(' ').filter(word => word !== '').length\n   * @example (text) => text.split(/\\s+/).filter(word => word !== '').length\n   */\n  wordCounter: (text: string) => number\n}\n\nexport interface CharacterCountStorage {\n  /**\n   * Get the number of characters for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the characters from. Defaults to the current document.\n   * @param options.mode The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   */\n  characters: (options?: { node?: ProseMirrorNode; mode?: 'textSize' | 'nodeSize' }) => number\n\n  /**\n   * Get the number of words for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the words from. Defaults to the current document.\n   */\n  words: (options?: { node?: ProseMirrorNode }) => number\n}\n\ndeclare module '@tiptap/core' {\n  interface Storage {\n    characterCount: CharacterCountStorage\n  }\n}\n\n/**\n * This extension allows you to count the characters and words of your document.\n * @see https://tiptap.dev/api/extensions/character-count\n */\nexport const CharacterCount = Extension.create<CharacterCountOptions, CharacterCountStorage>({\n  name: 'characterCount',\n\n  addOptions() {\n    return {\n      limit: null,\n      mode: 'textSize',\n      textCounter: text => text.length,\n      wordCounter: text => text.split(' ').filter(word => word !== '').length,\n    }\n  },\n\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0,\n    }\n  },\n\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = options?.node || this.editor.state.doc\n      const mode = options?.mode || this.options.mode\n\n      if (mode === 'textSize') {\n        const text = node.textBetween(0, node.content.size, undefined, ' ')\n\n        return this.options.textCounter(text)\n      }\n\n      return node.nodeSize\n    }\n\n    this.storage.words = options => {\n      const node = options?.node || this.editor.state.doc\n      const text = node.textBetween(0, node.content.size, ' ', ' ')\n\n      return this.options.wordCounter(text)\n    }\n  },\n\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('characterCount'),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return\n          }\n\n          const limit = this.options.limit\n\n          if (limit === null || limit === undefined || limit === 0) {\n            initialEvaluationDone = true\n            return\n          }\n\n          const initialContentSize = this.storage.characters({ node: newState.doc })\n\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit\n            const from = 0\n            const to = over\n\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`,\n            )\n            const tr = newState.tr.deleteRange(from, to)\n\n            initialEvaluationDone = true\n            return tr\n          }\n\n          initialEvaluationDone = true\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit\n\n          // Nothing has changed or no limit is defined. Ignore it.\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {\n            return true\n          }\n\n          const oldSize = this.storage.characters({ node: state.doc })\n          const newSize = this.storage.characters({ node: transaction.doc })\n\n          // Everything is in the limit. Good.\n          if (newSize <= limit) {\n            return true\n          }\n\n          // The limit has already been exceeded but will be reduced.\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true\n          }\n\n          // The limit has already been exceeded and will be increased further.\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false\n          }\n\n          const isPaste = transaction.getMeta('paste')\n\n          // Block all exceeding transactions that were not pasted.\n          if (!isPaste) {\n            return false\n          }\n\n          // For pasted content, we try to remove the exceeding content.\n          const pos = transaction.selection.$head.pos\n          const over = newSize - limit\n          const from = pos - over\n          const to = pos\n\n          // It’s probably a bad idea to mutate transactions within `filterTransaction`\n          // but for now this is working fine.\n          transaction.deleteRange(from, to)\n\n          // In some situations, the limit will continue to be exceeded after trimming.\n          // This happens e.g. when truncating within a complex node (e.g. table)\n          // and ProseMirror has to close this node again.\n          // If this is the case, we prevent the transaction completely.\n          const updatedSize = this.storage.characters({ node: transaction.doc })\n\n          if (updatedSize > limit) {\n            return false\n          }\n\n          return true\n        },\n      }),\n    ]\n  },\n})\n", "import { Extension } from '@tiptap/core'\nimport { dropCursor } from '@tiptap/pm/dropcursor'\n\nexport interface DropcursorOptions {\n  /**\n   * The color of the drop cursor. Use `false` to apply no color and rely only on class.\n   * @default 'currentColor'\n   * @example 'red'\n   */\n  color?: string | false\n\n  /**\n   * The width of the drop cursor\n   * @default 1\n   * @example 2\n   */\n  width: number | undefined\n\n  /**\n   * The class of the drop cursor\n   * @default undefined\n   * @example 'drop-cursor'\n   */\n  class: string | undefined\n}\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * in-between nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */\nexport const Dropcursor = Extension.create<DropcursorOptions>({\n  name: 'dropCursor',\n\n  addOptions() {\n    return {\n      color: 'currentColor',\n      width: 1,\n      class: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [dropCursor(this.options)]\n  },\n})\n", "import { Extension } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport interface FocusOptions {\n  /**\n   * The class name that should be added to the focused node.\n   * @default 'has-focus'\n   * @example 'is-focused'\n   */\n  className: string\n\n  /**\n   * The mode by which the focused node is determined.\n   * - All: All nodes are marked as focused.\n   * - Deepest: Only the deepest node is marked as focused.\n   * - Shallowest: Only the shallowest node is marked as focused.\n   *\n   * @default 'all'\n   * @example 'deepest'\n   * @example 'shallowest'\n   */\n  mode: 'all' | 'deepest' | 'shallowest'\n}\n\n/**\n * This extension allows you to add a class to the focused node.\n * @see https://www.tiptap.dev/api/extensions/focus\n */\nexport const Focus = Extension.create<FocusOptions>({\n  name: 'focus',\n\n  addOptions() {\n    return {\n      className: 'has-focus',\n      mode: 'all',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('focus'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!isEditable || !isFocused) {\n              return DecorationSet.create(doc, [])\n            }\n\n            // Maximum Levels\n            let maxLevels = 0\n\n            if (this.options.mode === 'deepest') {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return\n                }\n\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n                if (!isCurrent) {\n                  return false\n                }\n\n                maxLevels += 1\n              })\n            }\n\n            // Loop through current\n            let currentLevel = 0\n\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false\n              }\n\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n              if (!isCurrent) {\n                return false\n              }\n\n              currentLevel += 1\n\n              const outOfScope =\n                (this.options.mode === 'deepest' && maxLevels - currentLevel > 0) ||\n                (this.options.mode === 'shallowest' && currentLevel > 1)\n\n              if (outOfScope) {\n                return this.options.mode === 'deepest'\n              }\n\n              decorations.push(\n                Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className,\n                }),\n              )\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import type { ParentConfig } from '@tiptap/core'\nimport { callOrReturn, Extension, getExtensionField } from '@tiptap/core'\nimport { gapCursor } from '@tiptap/pm/gapcursor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A function to determine whether the gap cursor is allowed at the current position. Must return `true` or `false`.\n     * @default null\n     */\n    allowGapCursor?:\n      | boolean\n      | null\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options>>['allowGapCursor']\n        }) => boolean | null)\n  }\n}\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nexport const Gapcursor = Extension.create({\n  name: 'gapCursor',\n\n  addProseMirrorPlugins() {\n    return [gapCursor()]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      allowGapCursor: callOrReturn(getExtensionField(extension, 'allowGapCursor', context)) ?? null,\n    }\n  },\n})\n", "import type { Editor } from '@tiptap/core'\nimport { Extension, isNodeEmpty } from '@tiptap/core'\nimport type { Node as ProsemirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport interface PlaceholderOptions {\n  /**\n   * **The class name for the empty editor**\n   * @default 'is-editor-empty'\n   */\n  emptyEditorClass: string\n\n  /**\n   * **The class name for empty nodes**\n   * @default 'is-empty'\n   */\n  emptyNodeClass: string\n\n  /**\n   * **The placeholder content**\n   *\n   * You can use a function to return a dynamic placeholder or a string.\n   * @default 'Write something …'\n   */\n  placeholder:\n    | ((PlaceholderProps: { editor: Editor; node: ProsemirrorNode; pos: number; hasAnchor: boolean }) => string)\n    | string\n\n  /**\n   * **Checks if the placeholder should be only shown when the editor is editable.**\n   *\n   * If true, the placeholder will only be shown when the editor is editable.\n   * If false, the placeholder will always be shown.\n   * @default true\n   */\n  showOnlyWhenEditable: boolean\n\n  /**\n   * **Checks if the placeholder should be only shown when the current node is empty.**\n   *\n   * If true, the placeholder will only be shown when the current node is empty.\n   * If false, the placeholder will be shown when any node is empty.\n   * @default true\n   */\n  showOnlyCurrent: boolean\n\n  /**\n   * **Controls if the placeholder should be shown for all descendents.**\n   *\n   * If true, the placeholder will be shown for all descendents.\n   * If false, the placeholder will only be shown for the current node.\n   * @default false\n   */\n  includeChildren: boolean\n}\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: 'placeholder',\n\n  addOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      placeholder: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('placeholder'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!active) {\n              return null\n            }\n\n            const isEmptyDoc = this.editor.isEmpty\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize\n              const isEmpty = !node.isLeaf && isNodeEmpty(node)\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass]\n\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass)\n                }\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(' '),\n                  'data-placeholder':\n                    typeof this.options.placeholder === 'function'\n                      ? this.options.placeholder({\n                          editor: this.editor,\n                          node,\n                          pos,\n                          hasAnchor,\n                        })\n                      : this.options.placeholder,\n                })\n\n                decorations.push(decoration)\n              }\n\n              return this.options.includeChildren\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { Extension, isNodeSelection } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport type SelectionOptions = {\n  /**\n   * The class name that should be added to the selected text.\n   * @default 'selection'\n   * @example 'is-selected'\n   */\n  className: string\n}\n\n/**\n * This extension allows you to add a class to the selected text.\n * @see https://www.tiptap.dev/api/extensions/selection\n */\nexport const Selection = Extension.create<SelectionOptions>({\n  name: 'selection',\n\n  addOptions() {\n    return {\n      className: 'selection',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const { editor, options } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('selection'),\n        props: {\n          decorations(state) {\n            if (\n              state.selection.empty ||\n              editor.isFocused ||\n              !editor.isEditable ||\n              isNodeSelection(state.selection) ||\n              editor.view.dragging\n            ) {\n              return null\n            }\n\n            return DecorationSet.create(state.doc, [\n              Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className,\n              }),\n            ])\n          },\n        },\n      }),\n    ]\n  },\n})\n\nexport default Selection\n", "import { Extension } from '@tiptap/core'\nimport type { Node, NodeType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nfunction nodeEqualsType({ types, node }: { types: NodeType | NodeType[]; node: Node | null | undefined }) {\n  return (node && Array.isArray(types) && types.includes(node.type)) || node?.type === types\n}\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  /**\n   * The node type that should be inserted at the end of the document.\n   * @note the node will always be added to the `notAfter` lists to\n   * prevent an infinite loop.\n   * @default 'paragraph'\n   */\n  node?: string\n  /**\n   * The node types after which the trailing node should not be inserted.\n   * @default ['paragraph']\n   */\n  notAfter?: string | string[]\n}\n\n/**\n * This extension allows you to add an extra node at the end of the document.\n * @see https://www.tiptap.dev/api/extensions/trailing-node\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: 'trailingNode',\n\n  addOptions() {\n    return {\n      node: undefined,\n      notAfter: [],\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name)\n    const defaultNode =\n      this.editor.schema.topNodeType.contentMatch.defaultType?.name || this.options.node || 'paragraph'\n\n    const disabledNodes = Object.entries(this.editor.schema.nodes)\n      .map(([, value]) => value)\n      .filter(node => (this.options.notAfter || []).concat(defaultNode).includes(node.name))\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state\n          const shouldInsertNodeAtEnd = plugin.getState(state)\n          const endPosition = doc.content.size\n          const type = schema.nodes[defaultNode]\n\n          if (!shouldInsertNodeAtEnd) {\n            return\n          }\n\n          return tr.insert(endPosition, type.create())\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value\n            }\n\n            const lastNode = tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { Extension } from '@tiptap/core'\nimport { history, redo, undo } from '@tiptap/pm/history'\n\nexport interface UndoRedoOptions {\n  /**\n   * The amount of history events that are collected before the oldest events are discarded.\n   * @default 100\n   * @example 50\n   */\n  depth: number\n\n  /**\n   * The delay (in milliseconds) between changes after which a new group should be started.\n   * @default 500\n   * @example 1000\n   */\n  newGroupDelay: number\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoRedo: {\n      /**\n       * Undo recent changes\n       * @example editor.commands.undo()\n       */\n      undo: () => ReturnType\n      /**\n       * Reapply reverted changes\n       * @example editor.commands.redo()\n       */\n      redo: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/undo-redo\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `undo-redo` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nexport const UndoRedo = Extension.create<UndoRedoOptions>({\n  name: 'undoRedo',\n\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500,\n    }\n  },\n\n  addCommands() {\n    return {\n      undo:\n        () =>\n        ({ state, dispatch }) => {\n          return undo(state, dispatch)\n        },\n      redo:\n        () =>\n        ({ state, dispatch }) => {\n          return redo(state, dispatch)\n        },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [history(this.options)]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n      'Mod-y': () => this.editor.commands.redo(),\n\n      // Russian keyboard layouts\n      'Mod-я': () => this.editor.commands.undo(),\n      'Shift-Mod-я': () => this.editor.commands.redo(),\n    }\n  },\n})\n", "import { Extension } from '@tiptap/core'\nimport type { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport { Blockquote } from '@tiptap/extension-blockquote'\nimport type { BoldOptions } from '@tiptap/extension-bold'\nimport { Bold } from '@tiptap/extension-bold'\nimport type { CodeOptions } from '@tiptap/extension-code'\nimport { Code } from '@tiptap/extension-code'\nimport type { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport { CodeBlock } from '@tiptap/extension-code-block'\nimport { Document } from '@tiptap/extension-document'\nimport type { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport { HardBreak } from '@tiptap/extension-hard-break'\nimport type { HeadingOptions } from '@tiptap/extension-heading'\nimport { Heading } from '@tiptap/extension-heading'\nimport type { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport { HorizontalRule } from '@tiptap/extension-horizontal-rule'\nimport type { ItalicOptions } from '@tiptap/extension-italic'\nimport { Italic } from '@tiptap/extension-italic'\nimport type { LinkOptions } from '@tiptap/extension-link'\nimport { Link } from '@tiptap/extension-link'\nimport type { BulletListOptions, ListItemOptions, ListKeymapOptions, OrderedListOptions } from '@tiptap/extension-list'\nimport { BulletList, ListItem, ListKeymap, OrderedList } from '@tiptap/extension-list'\nimport type { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport { Paragraph } from '@tiptap/extension-paragraph'\nimport type { StrikeOptions } from '@tiptap/extension-strike'\nimport { Strike } from '@tiptap/extension-strike'\nimport { Text } from '@tiptap/extension-text'\nimport type { UnderlineOptions } from '@tiptap/extension-underline'\nimport { Underline } from '@tiptap/extension-underline'\nimport type { DropcursorOptions, TrailingNodeOptions, UndoRedoOptions } from '@tiptap/extensions'\nimport { Dropcursor, Gapcursor, TrailingNode, UndoRedo } from '@tiptap/extensions'\n\nexport interface StarterKitOptions {\n  /**\n   * If set to false, the blockquote extension will not be registered\n   * @example blockquote: false\n   */\n  blockquote: Partial<BlockquoteOptions> | false\n\n  /**\n   * If set to false, the bold extension will not be registered\n   * @example bold: false\n   */\n  bold: Partial<BoldOptions> | false\n\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example bulletList: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n\n  /**\n   * If set to false, the code extension will not be registered\n   * @example code: false\n   */\n  code: Partial<CodeOptions> | false\n\n  /**\n   * If set to false, the codeBlock extension will not be registered\n   * @example codeBlock: false\n   */\n  codeBlock: Partial<CodeBlockOptions> | false\n\n  /**\n   * If set to false, the document extension will not be registered\n   * @example document: false\n   */\n  document: false\n\n  /**\n   * If set to false, the dropcursor extension will not be registered\n   * @example dropcursor: false\n   */\n  dropcursor: Partial<DropcursorOptions> | false\n\n  /**\n   * If set to false, the gapcursor extension will not be registered\n   * @example gapcursor: false\n   */\n  gapcursor: false\n\n  /**\n   * If set to false, the hardBreak extension will not be registered\n   * @example hardBreak: false\n   */\n  hardBreak: Partial<HardBreakOptions> | false\n\n  /**\n   * If set to false, the heading extension will not be registered\n   * @example heading: false\n   */\n  heading: Partial<HeadingOptions> | false\n\n  /**\n   * If set to false, the undo-redo extension will not be registered\n   * @example undoRedo: false\n   */\n  undoRedo: Partial<UndoRedoOptions> | false\n\n  /**\n   * If set to false, the horizontalRule extension will not be registered\n   * @example horizontalRule: false\n   */\n  horizontalRule: Partial<HorizontalRuleOptions> | false\n\n  /**\n   * If set to false, the italic extension will not be registered\n   * @example italic: false\n   */\n  italic: Partial<ItalicOptions> | false\n\n  /**\n   * If set to false, the listItem extension will not be registered\n   * @example listItem: false\n   */\n  listItem: Partial<ListItemOptions> | false\n\n  /**\n   * If set to false, the listItemKeymap extension will not be registered\n   * @example listKeymap: false\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n\n  /**\n   * If set to false, the link extension will not be registered\n   * @example link: false\n   */\n  link: Partial<LinkOptions> | false\n\n  /**\n   * If set to false, the orderedList extension will not be registered\n   * @example orderedList: false\n   */\n  orderedList: Partial<OrderedListOptions> | false\n\n  /**\n   * If set to false, the paragraph extension will not be registered\n   * @example paragraph: false\n   */\n  paragraph: Partial<ParagraphOptions> | false\n\n  /**\n   * If set to false, the strike extension will not be registered\n   * @example strike: false\n   */\n  strike: Partial<StrikeOptions> | false\n\n  /**\n   * If set to false, the text extension will not be registered\n   * @example text: false\n   */\n  text: false\n\n  /**\n   * If set to false, the underline extension will not be registered\n   * @example underline: false\n   */\n  underline: Partial<UnderlineOptions> | false\n\n  /**\n   * If set to false, the trailingNode extension will not be registered\n   * @example trailingNode: false\n   */\n  trailingNode: Partial<TrailingNodeOptions> | false\n}\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */\nexport const StarterKit = Extension.create<StarterKitOptions>({\n  name: 'starterKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bold !== false) {\n      extensions.push(Bold.configure(this.options.bold))\n    }\n\n    if (this.options.blockquote !== false) {\n      extensions.push(Blockquote.configure(this.options.blockquote))\n    }\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.code !== false) {\n      extensions.push(Code.configure(this.options.code))\n    }\n\n    if (this.options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(this.options.codeBlock))\n    }\n\n    if (this.options.document !== false) {\n      extensions.push(Document.configure(this.options.document))\n    }\n\n    if (this.options.dropcursor !== false) {\n      extensions.push(Dropcursor.configure(this.options.dropcursor))\n    }\n\n    if (this.options.gapcursor !== false) {\n      extensions.push(Gapcursor.configure(this.options.gapcursor))\n    }\n\n    if (this.options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(this.options.hardBreak))\n    }\n\n    if (this.options.heading !== false) {\n      extensions.push(Heading.configure(this.options.heading))\n    }\n\n    if (this.options.undoRedo !== false) {\n      extensions.push(UndoRedo.configure(this.options.undoRedo))\n    }\n\n    if (this.options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(this.options.horizontalRule))\n    }\n\n    if (this.options.italic !== false) {\n      extensions.push(Italic.configure(this.options.italic))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options?.listKeymap))\n    }\n\n    if (this.options.link !== false) {\n      extensions.push(Link.configure(this.options?.link))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.paragraph !== false) {\n      extensions.push(Paragraph.configure(this.options.paragraph))\n    }\n\n    if (this.options.strike !== false) {\n      extensions.push(Strike.configure(this.options.strike))\n    }\n\n    if (this.options.text !== false) {\n      extensions.push(Text.configure(this.options.text))\n    }\n\n    if (this.options.underline !== false) {\n      extensions.push(Underline.configure(this.options?.underline))\n    }\n\n    if (this.options.trailingNode !== false) {\n      extensions.push(TrailingNode.configure(this.options?.trailingNode))\n    }\n\n    return extensions\n  },\n})\n", "import { StarterKit } from './starter-kit.js'\n\nexport type { StarterKitOptions } from './starter-kit.js'\nexport * from './starter-kit.js'\n\nexport default StarterKit\n"],
  "mappings": "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",
  "names": ["h", "h", "inputRegex", "h", "h", "from", "_a", "h", "h", "starInputRegex", "starPasteRegex", "underscoreInputRegex", "underscorePasteRegex", "h", "h", "Node", "mergeAttributes", "getNodeType", "isNodeActive", "ListItemName", "TextStyleName", "wrappingInputRule", "inputRegex", "renderNestedMarkdownContent", "Extension", "h", "inputRegex", "pasteRegex", "h", "rect", "RopeSequence", "from", "Leaf", "Append", "appendInner", "map", "from", "history", "redo", "redo", "from", "Extension", "Plugin", "PluginKey", "Decoration", "DecorationSet", "Selection"]
}
